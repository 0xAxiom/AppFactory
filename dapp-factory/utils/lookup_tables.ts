/**\n * Address Lookup Table (LUT) Utilities for Bags API\n * \n * Implements LUT handling per Bags principles:\n * https://docs.bags.fm/principles/lookup-tables\n */\n\nimport { \n  Connection, \n  PublicKey, \n  AddressLookupTableProgram,\n  TransactionMessage,\n  VersionedTransaction,\n  AddressLookupTableAccount\n} from '@solana/web3.js';\nimport { BAGS_LOOKUP_TABLES, BAGS_PROGRAM_IDS } from '../constants/bags.js';\n\nexport interface LookupTableInfo {\n  address: PublicKey;\n  account: AddressLookupTableAccount;\n  addresses: PublicKey[];\n}\n\nexport interface LookupTableCreationResult {\n  address: PublicKey;\n  transactions: VersionedTransaction[];\n  waitSlots: number;\n}\n\n/**\n * Get Bags public lookup table information\n */\nexport async function getBagsLookupTable(\n  connection: Connection\n): Promise<LookupTableInfo> {\n  const lutAddress = new PublicKey(BAGS_LOOKUP_TABLES.MAINNET_LUT_ADDRESS);\n  \n  console.log(`üìã Loading Bags lookup table: ${lutAddress.toString()}`);\n  \n  const lookupTableAccount = await connection.getAddressLookupTable(lutAddress);\n  \n  if (!lookupTableAccount.value) {\n    throw new Error(`Bags lookup table not found at address: ${lutAddress.toString()}`);\n  }\n  \n  console.log(`‚úÖ Loaded lookup table with ${lookupTableAccount.value.state.addresses.length} addresses`);\n  \n  return {\n    address: lutAddress,\n    account: lookupTableAccount.value,\n    addresses: lookupTableAccount.value.state.addresses\n  };\n}\n\n/**\n * Check if lookup table is required for fee share configuration\n * Based on Bags docs: mandatory for >15 fee claimers\n */\nexport function isLookupTableRequired(feeClaimersCount: number): boolean {\n  return feeClaimersCount > BAGS_LOOKUP_TABLES.REQUIRED_FOR_FEE_CLAIMERS_THRESHOLD;\n}\n\n/**\n * Create lookup table transactions for fee share config\n * Based on Bags SDK helper function pattern\n */\nexport async function createLookupTableTransactions(\n  connection: Connection,\n  payer: PublicKey,\n  addresses: PublicKey[]\n): Promise<LookupTableCreationResult> {\n  console.log(`üîß Creating lookup table for ${addresses.length} addresses`);\n  \n  const transactions: VersionedTransaction[] = [];\n  \n  // Step 1: Create the lookup table\n  const [createLutInstruction, lutAddress] = \n    AddressLookupTableProgram.createLookupTable({\n      authority: payer,\n      payer: payer,\n      recentSlot: await connection.getSlot()\n    });\n  \n  // Create transaction for LUT creation\n  const createTxMessage = new TransactionMessage({\n    payerKey: payer,\n    recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n    instructions: [createLutInstruction]\n  });\n  \n  const createTx = new VersionedTransaction(createTxMessage.compileToV0Message([]));\n  transactions.push(createTx);\n  \n  console.log(`üìç Lookup table address: ${lutAddress.toString()}`);\n  \n  // Step 2: Extend lookup table with addresses (in batches)\n  const ADDRESSES_PER_EXTEND = 20; // Conservative batch size\n  \n  for (let i = 0; i < addresses.length; i += ADDRESSES_PER_EXTEND) {\n    const batch = addresses.slice(i, i + ADDRESSES_PER_EXTEND);\n    \n    const extendInstruction = AddressLookupTableProgram.extendLookupTable({\n      lookupTable: lutAddress,\n      authority: payer,\n      payer: payer,\n      addresses: batch\n    });\n    \n    const extendTxMessage = new TransactionMessage({\n      payerKey: payer,\n      recentBlockhash: (await connection.getLatestBlockhash()).blockhash,\n      instructions: [extendInstruction]\n    });\n    \n    const extendTx = new VersionedTransaction(extendTxMessage.compileToV0Message([]));\n    transactions.push(extendTx);\n    \n    console.log(`üìù Created extend transaction for batch ${Math.floor(i / ADDRESSES_PER_EXTEND) + 1}`);\n  }\n  \n  return {\n    address: lutAddress,\n    transactions,\n    waitSlots: 1 // Must wait 1 slot after creation before extension\n  };\n}\n\n/**\n * Get essential Bags program addresses for lookup table\n */\nexport function getBagsProgramAddresses(): PublicKey[] {\n  return [\n    new PublicKey(BAGS_PROGRAM_IDS.FEE_SHARE_V2),\n    new PublicKey(BAGS_PROGRAM_IDS.METEORA_DAMM_V2),\n    new PublicKey(BAGS_PROGRAM_IDS.METEORA_DBC)\n  ];\n}\n\n/**\n * Prepare addresses for lookup table based on fee configuration\n */\nexport function prepareFeeClaimerAddresses(\n  feeClaimers: Array<{ wallet: string; bps: number }>\n): PublicKey[] {\n  const addresses: PublicKey[] = [];\n  \n  // Add fee claimer wallets\n  for (const claimer of feeClaimers) {\n    try {\n      addresses.push(new PublicKey(claimer.wallet));\n    } catch (error) {\n      throw new Error(`Invalid fee claimer wallet address: ${claimer.wallet}`);\n    }\n  }\n  \n  // Add essential Bags program addresses\n  addresses.push(...getBagsProgramAddresses());\n  \n  console.log(`üìù Prepared ${addresses.length} addresses for lookup table`);\n  \n  return addresses;\n}\n\n/**\n * Execute lookup table creation with proper timing\n */\nexport async function executeLookupTableCreation(\n  connection: Connection,\n  transactions: VersionedTransaction[],\n  waitSlots: number\n): Promise<{\n  signatures: string[];\n  lookupTableAddress: PublicKey;\n}> {\n  const signatures: string[] = [];\n  \n  if (transactions.length === 0) {\n    throw new Error('No transactions provided for lookup table creation');\n  }\n  \n  console.log(`üöÄ Executing ${transactions.length} lookup table transactions...`);\n  \n  // Execute creation transaction\n  const createSignature = await connection.sendAndConfirmTransaction(transactions[0]!);\n  signatures.push(createSignature);\n  \n  console.log(`‚úÖ Lookup table created: ${createSignature}`);\n  \n  // Wait required slots before extending\n  if (waitSlots > 0 && transactions.length > 1) {\n    console.log(`‚è≥ Waiting ${waitSlots} slot(s) before extending...`);\n    \n    const targetSlot = await connection.getSlot() + waitSlots;\n    \n    while ((await connection.getSlot()) < targetSlot) {\n      await new Promise(resolve => setTimeout(resolve, 1000));\n    }\n  }\n  \n  // Execute extend transactions\n  for (let i = 1; i < transactions.length; i++) {\n    const extendSignature = await connection.sendAndConfirmTransaction(transactions[i]!);\n    signatures.push(extendSignature);\n    \n    console.log(`‚úÖ Lookup table extended (batch ${i}): ${extendSignature}`);\n  }\n  \n  // Extract lookup table address from first transaction\n  // This would need to be derived from the transaction or passed separately\n  // For now, we'll throw an error indicating this needs to be implemented\n  throw new Error('Lookup table address extraction not implemented - need to derive from first transaction');\n}\n\n/**\n * Check if a fee share config requires custom lookup table\n */\nexport function requiresCustomLookupTable(\n  feeClaimers: Array<{ wallet: string; bps: number }>,\n  existingLUT?: LookupTableInfo\n): boolean {\n  // Always required if more than threshold\n  if (isLookupTableRequired(feeClaimers.length)) {\n    return true;\n  }\n  \n  // Check if existing LUT contains all required addresses\n  if (existingLUT) {\n    const requiredAddresses = prepareFeeClaimerAddresses(feeClaimers);\n    const lutAddresses = existingLUT.addresses.map(addr => addr.toString());\n    \n    return !requiredAddresses.every(addr => \n      lutAddresses.includes(addr.toString())\n    );\n  }\n  \n  return false;\n}\n\n/**\n * Get lookup table configuration for Bags fee share config\n */\nexport async function getLookupTableConfig(\n  connection: Connection,\n  feeClaimers: Array<{ wallet: string; bps: number }>\n): Promise<{\n  useBagsLUT: boolean;\n  customLUTRequired: boolean;\n  bagsLUT?: LookupTableInfo;\n  customLUTAddresses?: PublicKey[];\n}> {\n  const customLUTRequired = requiresCustomLookupTable(feeClaimers);\n  \n  let bagsLUT: LookupTableInfo | undefined;\n  \n  try {\n    bagsLUT = await getBagsLookupTable(connection);\n  } catch (error) {\n    console.warn(`‚ö†Ô∏è Could not load Bags lookup table: ${error instanceof Error ? error.message : error}`);\n  }\n  \n  const customLUTAddresses = customLUTRequired ? \n    prepareFeeClaimerAddresses(feeClaimers) :\n    undefined;\n  \n  return {\n    useBagsLUT: !!bagsLUT,\n    customLUTRequired,\n    bagsLUT,\n    customLUTAddresses\n  };\n}\n\n/**\n * Log lookup table configuration for transparency\n */\nexport function logLookupTableInfo(\n  feeClaimersCount: number,\n  config: {\n    useBagsLUT: boolean;\n    customLUTRequired: boolean;\n    bagsLUT?: LookupTableInfo;\n  }\n): void {\n  console.log(`üìã Lookup Table Configuration:`);\n  console.log(`   Fee claimers count: ${feeClaimersCount}`);\n  console.log(`   Threshold for LUT requirement: ${BAGS_LOOKUP_TABLES.REQUIRED_FOR_FEE_CLAIMERS_THRESHOLD}`);\n  console.log(`   LUT required: ${isLookupTableRequired(feeClaimersCount)}`);\n  console.log(`   Using Bags public LUT: ${config.useBagsLUT}`);\n  \n  if (config.bagsLUT) {\n    console.log(`   Bags LUT address: ${config.bagsLUT.address.toString()}`);\n    console.log(`   Bags LUT contains ${config.bagsLUT.addresses.length} addresses`);\n  }\n  \n  console.log(`   Custom LUT required: ${config.customLUTRequired}`);\n}