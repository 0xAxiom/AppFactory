/**\n * Retry Utilities for Bags API Integration\n * \n * Implements rate limiting and error handling per Bags principles:\n * - https://docs.bags.fm/principles/error-handling\n * - https://docs.bags.fm/principles/rate-limits\n */\n\nimport { \n  BAGS_ERROR_HANDLING, \n  BAGS_RATE_LIMITS, \n  isRetryableError, \n  calculateBackoffDelay \n} from '../constants/bags.js';\n\nexport interface RetryOptions {\n  maxAttempts?: number;\n  initialDelay?: number;\n  maxDelay?: number;\n  backoffMultiplier?: number;\n  retryCondition?: (error: any) => boolean;\n  onRetry?: (attempt: number, error: any) => void;\n}\n\nexport interface RateLimitInfo {\n  limit: number;\n  remaining: number;\n  resetTime: number;\n}\n\nexport class BagsApiError extends Error {\n  public readonly statusCode: number;\n  public readonly rateLimitInfo?: RateLimitInfo;\n  public readonly isRetryable: boolean;\n  \n  constructor(\n    message: string, \n    statusCode: number, \n    rateLimitInfo?: RateLimitInfo\n  ) {\n    super(message);\n    this.name = 'BagsApiError';\n    this.statusCode = statusCode;\n    this.rateLimitInfo = rateLimitInfo;\n    this.isRetryable = isRetryableError(statusCode);\n  }\n}\n\n/**\n * Retry function with exponential backoff and rate limit awareness\n */\nexport async function withRetry<T>(\n  operation: () => Promise<T>,\n  options: RetryOptions = {}\n): Promise<T> {\n  const {\n    maxAttempts = BAGS_ERROR_HANDLING.MAX_RETRY_ATTEMPTS,\n    initialDelay = BAGS_ERROR_HANDLING.INITIAL_RETRY_DELAY_MS,\n    maxDelay = 30000, // 30 seconds max delay\n    backoffMultiplier = BAGS_ERROR_HANDLING.EXPONENTIAL_BACKOFF_BASE,\n    retryCondition = defaultRetryCondition,\n    onRetry\n  } = options;\n\n  let lastError: Error;\n  \n  for (let attempt = 1; attempt <= maxAttempts; attempt++) {\n    try {\n      const result = await operation();\n      return result;\n    } catch (error) {\n      lastError = error as Error;\n      \n      // Check if we should retry\n      if (attempt === maxAttempts || !retryCondition(error)) {\n        throw error;\n      }\n      \n      // Calculate delay with exponential backoff\n      let delay = Math.min(\n        initialDelay * Math.pow(backoffMultiplier, attempt - 1),\n        maxDelay\n      );\n      \n      // Special handling for rate limit errors\n      if (error instanceof BagsApiError && error.statusCode === 429) {\n        if (error.rateLimitInfo) {\n          // Use the reset time if available\n          const resetDelay = Math.max(\n            (error.rateLimitInfo.resetTime * 1000) - Date.now(),\n            delay\n          );\n          delay = Math.min(resetDelay, maxDelay);\n        } else {\n          // Conservative rate limit backoff\n          delay = Math.min(delay * 2, maxDelay);\n        }\n        \n        console.warn(`â±ï¸ Rate limited, waiting ${Math.round(delay / 1000)}s before retry ${attempt}/${maxAttempts}`);\n      } else {\n        console.warn(`ðŸ”„ Retrying attempt ${attempt}/${maxAttempts} after ${Math.round(delay)}ms delay`);\n      }\n      \n      // Call retry callback if provided\n      if (onRetry) {\n        onRetry(attempt, error);\n      }\n      \n      // Wait before retrying\n      await sleep(delay);\n    }\n  }\n  \n  throw lastError;\n}\n\n/**\n * Default retry condition based on Bags error handling principles\n */\nfunction defaultRetryCondition(error: any): boolean {\n  if (error instanceof BagsApiError) {\n    return error.isRetryable;\n  }\n  \n  // Network errors, timeouts, etc.\n  if (error instanceof TypeError || error.message?.includes('fetch')) {\n    return true;\n  }\n  \n  return false;\n}\n\n/**\n * Sleep utility\n */\nfunction sleep(ms: number): Promise<void> {\n  return new Promise(resolve => setTimeout(resolve, ms));\n}\n\n/**\n * Enhanced fetch with Bags API error handling\n */\nexport async function bagsApiFetch(\n  url: string,\n  options: RequestInit = {}\n): Promise<Response> {\n  const response = await fetch(url, {\n    ...options,\n    headers: {\n      'Content-Type': 'application/json',\n      ...options.headers\n    }\n  });\n  \n  // Parse rate limit headers\n  const rateLimitInfo: RateLimitInfo | undefined = response.headers.get(BAGS_RATE_LIMITS.HEADERS.LIMIT) ? {\n    limit: parseInt(response.headers.get(BAGS_RATE_LIMITS.HEADERS.LIMIT) || '0'),\n    remaining: parseInt(response.headers.get(BAGS_RATE_LIMITS.HEADERS.REMAINING) || '0'),\n    resetTime: parseInt(response.headers.get(BAGS_RATE_LIMITS.HEADERS.RESET) || '0')\n  } : undefined;\n  \n  // Log rate limit status\n  if (rateLimitInfo) {\n    console.log(`ðŸ“Š Rate limit: ${rateLimitInfo.remaining}/${rateLimitInfo.limit} remaining`);\n    \n    if (rateLimitInfo.remaining < 100) {\n      const resetDate = new Date(rateLimitInfo.resetTime * 1000);\n      console.warn(`âš ï¸ Low rate limit remaining: ${rateLimitInfo.remaining}. Resets at ${resetDate.toISOString()}`);\n    }\n  }\n  \n  // Handle errors\n  if (!response.ok) {\n    let errorMessage: string;\n    \n    try {\n      const errorData = await response.json();\n      errorMessage = errorData.error || errorData.message || `HTTP ${response.status}: ${response.statusText}`;\n    } catch {\n      errorMessage = `HTTP ${response.status}: ${response.statusText}`;\n    }\n    \n    throw new BagsApiError(errorMessage, response.status, rateLimitInfo);\n  }\n  \n  return response;\n}\n\n/**\n * Rate limit aware request queue\n */\nexport class BagsRequestQueue {\n  private queue: Array<() => Promise<void>> = [];\n  private processing = false;\n  private lastRequestTime = 0;\n  private minInterval: number;\n  \n  constructor() {\n    // Conservative rate limiting: slightly under the limit\n    this.minInterval = Math.ceil(60000 / (BAGS_RATE_LIMITS.REQUESTS_PER_MINUTE * 0.9)); // 90% of limit\n  }\n  \n  async enqueue<T>(operation: () => Promise<T>): Promise<T> {\n    return new Promise((resolve, reject) => {\n      this.queue.push(async () => {\n        try {\n          const result = await operation();\n          resolve(result);\n        } catch (error) {\n          reject(error);\n        }\n      });\n      \n      this.processQueue();\n    });\n  }\n  \n  private async processQueue(): Promise<void> {\n    if (this.processing || this.queue.length === 0) {\n      return;\n    }\n    \n    this.processing = true;\n    \n    while (this.queue.length > 0) {\n      const now = Date.now();\n      const timeSinceLastRequest = now - this.lastRequestTime;\n      \n      if (timeSinceLastRequest < this.minInterval) {\n        const delay = this.minInterval - timeSinceLastRequest;\n        console.log(`â³ Rate limiting: waiting ${delay}ms before next request`);\n        await sleep(delay);\n      }\n      \n      const operation = this.queue.shift()!;\n      this.lastRequestTime = Date.now();\n      \n      await operation();\n    }\n    \n    this.processing = false;\n  }\n}\n\n// Global request queue instance\nexport const globalRequestQueue = new BagsRequestQueue();