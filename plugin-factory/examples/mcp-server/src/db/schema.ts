/**
 * Database Schema for Decision Memory
 *
 * SQLite schema for storing architectural decisions.
 * Generated by Plugin Factory v1.0
 */

import Database, { Database as DatabaseType } from 'better-sqlite3';
import { homedir } from 'os';
import { join } from 'path';
import { mkdirSync, existsSync } from 'fs';

const DB_DIR = process.env.DECISION_DB_PATH
  ? process.env.DECISION_DB_PATH.replace(/\/[^/]+$/, '')
  : join(homedir(), '.decision-memory');

const DB_PATH = process.env.DECISION_DB_PATH || join(DB_DIR, 'decisions.db');

// Ensure directory exists
if (!existsSync(DB_DIR)) {
  mkdirSync(DB_DIR, { recursive: true });
}

export const db: DatabaseType = new Database(DB_PATH);

// Enable WAL mode for better concurrency
db.pragma('journal_mode = WAL');

// Create tables
db.exec(`
  -- Projects table
  CREATE TABLE IF NOT EXISTS projects (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    path TEXT UNIQUE NOT NULL,
    name TEXT NOT NULL,
    created_at TEXT NOT NULL DEFAULT (datetime('now'))
  );

  -- Decisions table
  CREATE TABLE IF NOT EXISTS decisions (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    files TEXT NOT NULL,
    reasoning TEXT NOT NULL,
    commit_hash TEXT,
    commit_url TEXT,
    tags TEXT NOT NULL DEFAULT '[]',
    context TEXT,
    created_at TEXT NOT NULL DEFAULT (datetime('now')),
    updated_at TEXT NOT NULL DEFAULT (datetime('now')),
    FOREIGN KEY (project_id) REFERENCES projects(id)
  );

  -- Full-text search index
  CREATE VIRTUAL TABLE IF NOT EXISTS decisions_fts USING fts5(
    reasoning,
    tags,
    content=decisions,
    content_rowid=id
  );

  -- Triggers to keep FTS in sync
  CREATE TRIGGER IF NOT EXISTS decisions_ai AFTER INSERT ON decisions BEGIN
    INSERT INTO decisions_fts(rowid, reasoning, tags)
    VALUES (new.id, new.reasoning, new.tags);
  END;

  CREATE TRIGGER IF NOT EXISTS decisions_ad AFTER DELETE ON decisions BEGIN
    INSERT INTO decisions_fts(decisions_fts, rowid, reasoning, tags)
    VALUES ('delete', old.id, old.reasoning, old.tags);
  END;

  CREATE TRIGGER IF NOT EXISTS decisions_au AFTER UPDATE ON decisions BEGIN
    INSERT INTO decisions_fts(decisions_fts, rowid, reasoning, tags)
    VALUES ('delete', old.id, old.reasoning, old.tags);
    INSERT INTO decisions_fts(rowid, reasoning, tags)
    VALUES (new.id, new.reasoning, new.tags);
  END;

  -- Indexes
  CREATE INDEX IF NOT EXISTS idx_decisions_project ON decisions(project_id);
  CREATE INDEX IF NOT EXISTS idx_decisions_created ON decisions(created_at);
  CREATE INDEX IF NOT EXISTS idx_decisions_commit ON decisions(commit_hash);
`);

// Types
export interface Project {
  id: number;
  path: string;
  name: string;
  created_at: string;
}

export interface Decision {
  id: number;
  project_id: number;
  files: string[];
  reasoning: string;
  commit_hash: string | null;
  commit_url: string | null;
  tags: string[];
  context: string | null;
  created_at: string;
  updated_at: string;
}

export interface DecisionWithProject extends Decision {
  project_path: string;
  project_name: string;
}

export { DB_PATH };
